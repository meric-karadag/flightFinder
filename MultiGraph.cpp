#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

#define INF float(0xFFFFFFFFFFFFFFF)
//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{
}

MultiGraph::MultiGraph(const std::string &filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if (!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if (line.empty())
            continue;
        // Comment Skip
        if (line[0] == '#')
            continue;

        // Tokenize the line
        size_t i = 0;
        std::istringstream stream(line);
        while (stream >> tokens[i])
            i++;

        // Single token (Meaning it is a vertex)
        if (i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if (i == 5)
        {
            // Rename vars for readablity
            const std::string &vertexFromName = tokens[0];
            const std::string &vertexToName = tokens[1];
            const std::string &edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else
            std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int> &orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int> &ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if (ove.size() < 3)
        return;

    // Check vertex and an edge
    for (size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if (vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }

        const GraphVertex &vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if (!sameLine)
            std::cout << "\n";
        // Only find and print the weight if next is available
        if (i == ove.size() - 1)
            break;
        int nextVertexId = ove[i + 2];
        if (nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if (localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge &edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if (sameLine)
        std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex &v = vertexList[i];
        std::cout << v.name << "\n";
        for (size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge &edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")"
                      << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
EdgeResult MultiGraph::FindEdge(const std::string &edgeName,
                                const std::string &vertexFromName,
                                const std::string &vertexToName)
{
    // Iterate through vertexList to see if From and To exists
    int fromIndex = -1;
    int toIndex = -1;
    int edgeIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexFromName)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexToName)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }
    // If either From or To does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexFromName);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexToName);
    }
    // If edge does not exists throw exception
    for (size_t i = 0; i < vertexList[fromIndex].edges.size(); i++)
    {
        if (vertexList[fromIndex].edges[i].name == edgeName && vertexList[fromIndex].edges[i].endVertexIndex == toIndex)
        {
            return EdgeResult(vertexList[fromIndex].edges[i].weight[0], vertexList[fromIndex].edges[i].weight[1]);
        }
    }
    throw EdgeNotFoundException(vertexFromName, edgeName);
}

VertexResult MultiGraph::FindVertex(const std::string &vertexFromName, const std::string &vertexToName) const
{
    int fromIndex = -1;
    int toIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexFromName)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexToName)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexFromName);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexToName);
    }
    return VertexResult(fromIndex, toIndex);
}

float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return w0 * (1 - alpha) + w1 * alpha;
}

void MultiGraph::InsertVertex(const std::string &vertexName)
{
    /* TODO */
    /* COMPLETE */
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexName)
        {
            throw DuplicateVertexException(vertexName);
        }
    }
    GraphVertex newVertex;
    newVertex.name = vertexName;
    vertexList.push_back(newVertex);
}

void MultiGraph::RemoveVertex(const std::string &vertexName)
{
    /* TODO */
    // Search the given vertex
    int deleteIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexName)
        {
            vertexList.erase(vertexList.begin() + i);
            deleteIndex = i;
            break;
        }
    }
    // If vertex found make necessary adjustements
    if (deleteIndex > -1)
    {
        for (size_t i = 0; i < vertexList.size(); i++)
        {
            for (int j = 0; j < vertexList[i].edges.size(); j++)
            {
                // If edge is to deleted node, delete the edge
                if (vertexList[i].edges[j].endVertexIndex == deleteIndex)
                {
                    vertexList[i].edges.erase(vertexList[i].edges.begin() + j);
                    j--;
                }
                // If edge is to a node after deleted node, decrement the index
                else if (vertexList[i].edges[j].endVertexIndex > deleteIndex)
                {
                    vertexList[i].edges[j].endVertexIndex--;
                }
            }
        }
    }

    else
    {
        throw VertexNotFoundException(vertexName);
    }
}
void MultiGraph::AddEdge(const std::string &edgeName,
                         const std::string &vertexFromName,
                         const std::string &vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    // Iterate through vertexList to see if From and To exists
    int fromIndex = -1;
    int toIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexFromName)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexToName)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }
    // If either From or To does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexFromName);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexToName);
    }
    // If edge with same name exists throw exception
    for (size_t i = 0; i < vertexList[fromIndex].edges.size(); i++)
    {
        if (vertexList[fromIndex].edges[i].name == edgeName && vertexList[fromIndex].edges[i].endVertexIndex == toIndex)
        {
            throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
        }
    }
    // If a new edge add to edges vector
    GraphEdge newEdge;
    newEdge.name = edgeName;
    newEdge.endVertexIndex = toIndex;
    newEdge.weight[0] = weight0;
    newEdge.weight[1] = weight1;
    vertexList[fromIndex].edges.push_back(newEdge);
}

void MultiGraph::RemoveEdge(const std::string &edgeName,
                            const std::string &vertexFromName,
                            const std::string &vertexToName)
{
    /* TODO */
    // Find the indices of the source and destination vertices
    int fromIndex = -1;
    int toIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexFromName)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexToName)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }
    // If either From or To does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexFromName);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexToName);
    }
    // Try to find edge, if edge does not exists throw exception
    for (size_t i = 0; i < vertexList[fromIndex].edges.size(); i++)
    {
        if (vertexList[fromIndex].edges[i].name == edgeName && vertexList[fromIndex].edges[i].endVertexIndex == toIndex)
        {
            vertexList[fromIndex].edges.erase(vertexList[fromIndex].edges.begin() + i);
            return;
        }
    }
    throw EdgeNotFoundException(vertexFromName, edgeName);
}

bool MultiGraph::HeuristicShortestPath(std::vector<int> &orderedVertexEdgeIndexList,
                                       const std::string &vertexNameFrom,
                                       const std::string &vertexNameTo,
                                       float heuristicWeight) const
{
    // Find the indices of the source and destination vertices
    int fromIndex = -1;
    int toIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexNameFrom)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexNameTo)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }

    // If either From or To does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexNameFrom);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexNameTo);
    }

    // Create priority queue of distance (float) and index (int) pairs
    // std::priority_queue<std::pair<float, int>, std::vector<std::pair<float, int>>, std::greater<std::pair<float, int>>> pq;
    std::priority_queue<Pair<float, int>, std::vector<Pair<float, int>>, DoubleGreaterComparator<Pair<float, int>>> pq;

    // Create a vector to store cummulative distances, initialize with INF value
    std::vector<float> distances(vertexList.size(), INF);

    // Create a vector to store the previous vertices
    std::vector<int> previous(vertexList.size(), -1);

    // Create a vector to store the edge indexes to reach the nodes
    std::vector<int> reachEdge(vertexList.size(), -1);

    distances[fromIndex] = 0;
    pq.push(Pair<float, int>(float(0), fromIndex));

    // Dijkstra's Shortest Path Algorithm
    while (!pq.empty())
    {
        int u = pq.top().value;
        float dist = pq.top().key;
        pq.pop();

        // If distance taken from pq is bigger than distance in vector it
        // means this is a artifact in priority queue, no need to process
        if (dist > distances[u])
            continue;

        // Stop if the destination vertex is reached
        if (u == toIndex)
            break;

        // Iterate through the edges of the current vertex
        for (size_t i = 0; i < vertexList[u].edges.size(); i++)
        {
            int v = vertexList[u].edges[i].endVertexIndex;
            float weight = Lerp(vertexList[u].edges[i].weight[0], vertexList[u].edges[i].weight[1], heuristicWeight);

            // If a shorter path is found update the distances vector and push to pq
            if (distances[u] + weight < distances[v])
            {
                distances[v] = distances[u] + weight;
                previous[v] = u;
                reachEdge[v] = i;
                pq.push(Pair<float, int>(float(distances[v]), v));
            }
        }
    }

    // If the destination vertex is not reached, no path exists
    if (previous[toIndex] == -1)
        return false;

    // Reconstruct the shortest path
    int current = toIndex;

    // Create a stack like priority queue, max heap due to priority will result in stack like structure
    std::priority_queue<Pair<int, int>, std::vector<Pair<int, int>>, DoubleLessComparator<Pair<int, int>>> PathStackLikePq;
    int priority = 0;
    while (current != -1)
    {
        // If current is not source add the edge used to reach current
        PathStackLikePq.push(Pair<int, int>(priority++, current));
        if (current != fromIndex)
        {
            PathStackLikePq.push(Pair<int, int>(priority++, reachEdge[current]));
        }
        current = previous[current];
    }
    while (!PathStackLikePq.empty())
    {
        orderedVertexEdgeIndexList.push_back(PathStackLikePq.top().value);
        PathStackLikePq.pop();
    }
    return true;
}

bool MultiGraph::FilteredShortestPath(std::vector<int> &orderedVertexEdgeIndexList,
                                      const std::string &vertexNameFrom,
                                      const std::string &vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string> &edgeNames) const
{
    int fromIndex = -1;
    int toIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexNameFrom)
        {
            fromIndex = i;
        }
        if (vertexList[i].name == vertexNameTo)
        {
            toIndex = i;
        }
        if (fromIndex != -1 && toIndex != -1)
            break;
    }

    // If either From or To does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexNameFrom);
    }
    if (toIndex == -1)
    {
        throw VertexNotFoundException(vertexNameTo);
    }
    std::priority_queue<Pair<float, int>, std::vector<Pair<float, int>>, DoubleGreaterComparator<Pair<float, int>>> pq;

    // Create a vector to store cummulative distances, initialize with INF value
    std::vector<float> distances(vertexList.size(), INF);

    // Create a vector to store the previous vertices
    std::vector<int> previous(vertexList.size(), -1);

    // Create a vector to store the edge indexes to reach the nodes
    std::vector<int> reachEdge(vertexList.size(), -1);

    distances[fromIndex] = 0;
    pq.push(Pair<float, int>(float(0), fromIndex));

    // Dijkstra's Shortest Path Algorithm
    while (!pq.empty())
    {
        int u = pq.top().value;
        float dist = pq.top().key;
        pq.pop();

        // If distance taken from pq is bigger than distance in vector it
        // means this is a artifact in priority queue, no need to process
        if (dist > distances[u])
            continue;

        // Stop if the destination vertex is reached
        if (u == toIndex)
            break;

        // Iterate through the edges of the current vertex
        for (size_t i = 0; i < vertexList[u].edges.size(); i++)
        {
            bool isFiltered = false;
            // Check if edge's name is in Filtered Edges List
            for (size_t j = 0; j < edgeNames.size(); j++)
            {
                if (vertexList[u].edges[i].name == edgeNames[j])
                {
                    isFiltered = true;
                    break;
                }
            }
            if (isFiltered)
                continue;

            int v = vertexList[u].edges[i].endVertexIndex;
            float weight = Lerp(vertexList[u].edges[i].weight[0], vertexList[u].edges[i].weight[1], heuristicWeight);

            // If a shorter path is found update the distances vector and push to pq
            if (distances[u] + weight < distances[v])
            {
                distances[v] = distances[u] + weight;
                previous[v] = u;
                reachEdge[v] = i;
                pq.push(Pair<float, int>(float(distances[v]), v));
            }
        }
    }

    // If the destination vertex is not reached, no path exists
    if (previous[toIndex] == -1)
        return false;

    // Reconstruct the shortest path
    int current = toIndex;

    // Create a stack like priority queue, max heap due to priority will result in stack like structure
    std::priority_queue<Pair<int, int>, std::vector<Pair<int, int>>, DoubleLessComparator<Pair<int, int>>> PathStackLikePq;
    int priority = 0;
    while (current != -1)
    {
        // If current is not source add the edge used to reach current
        PathStackLikePq.push(Pair<int, int>(priority++, current));
        if (current != fromIndex)
        {
            PathStackLikePq.push(Pair<int, int>(priority++, reachEdge[current]));
        }
        current = previous[current];
    }
    while (!PathStackLikePq.empty())
    {
        orderedVertexEdgeIndexList.push_back(PathStackLikePq.top().value);
        PathStackLikePq.pop();
    }
    return true;
}
int MultiGraph::BiDirectionalEdgeCount() const
{
    int result = 0;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        for (size_t j = 0; j < vertexList[i].edges.size(); j++)
        {
            int endVertexIndex = vertexList[i].edges[j].endVertexIndex;
            for (size_t k = 0; k < vertexList[endVertexIndex].edges.size(); k++)
            {
                if (vertexList[endVertexIndex].edges[k].endVertexIndex == i && vertexList[endVertexIndex].edges[k].name == vertexList[i].edges[j].name)
                {
                    result++;
                    break;
                }
            }
        }
    }
    return result / 2;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string &vertexName,
                                    const std::string &edgeName) const
{
    /* TODO */
    int result = 0;
    // Find the given vertex
    int fromIndex = -1;
    for (size_t i = 0; i < vertexList.size(); i++)
    {
        if (vertexList[i].name == vertexName)
        {
            fromIndex = i;
            break;
        }
    }
    // If vertex does not exist, throw exception
    if (fromIndex == -1)
    {
        throw VertexNotFoundException(vertexName);
    }

    // Create a queue like priority queue to perform BFS
    // first -> priority, second -> reached vertex index, third -> distance
    std::priority_queue<Triplet<int, int, int>, std::vector<Triplet<int, int, int>>, TripleLessComparator<Triplet<int, int, int>>> pq;

    // Create a visited vector to avoid loops
    std::vector<int> visited(vertexList.size(), 0);

    int priority = 999999;
    pq.push(Triplet<int, int, int>(priority--, fromIndex, 0));
    visited[fromIndex] = 1;
    while (!pq.empty())
    {
        int u = pq.top().second;
        int dist = pq.top().third;
        pq.pop();

        // If distance taken from pq is bigger than distance in vector it
        // means this is a artifact in priority queue, no need to process
        if (dist > result)
            result = dist;

        // Iterate through the edges of the current vertex
        for (size_t i = 0; i < vertexList[u].edges.size(); i++)
        {
            // If edge name is not the given edge name, continue
            if (vertexList[u].edges[i].name != edgeName)
                continue;

            int v = vertexList[u].edges[i].endVertexIndex;

            if (visited[v] == 1)
                continue;
            else
                visited[v] = 1;

            // If a deeper path is found update the result and push to pq
            pq.push(Triplet<int, int, int>(priority--, v, dist + 1));
            // if (dist + 1 > result)
            // {
            //     result = dist + 1;
            //     pq.push(Triplet<int, int, int>(priority--, v, dist + 1));
            // }
        }
    }
    return result;
}
